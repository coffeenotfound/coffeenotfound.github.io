<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>This isn't stolen... # coffeenotfound.github.io</title>
	
	<link href="/css/normalize.css" rel="stylesheet">
	<link href="/css/post.css" rel="stylesheet">
	
	<meta name="author" content="Jan Katzer">
	<meta name="description" content="After I decided that it would be useful for me to have an OBJ parser in my pile of code. There is a lot of OBJ content kicking around, for example Morgan McGuireâ€™s excellent data repository.

OBJ is a text-based format, which means Iâ€™d need to write a parser, and 3D models are big, which means my parser shouldnâ€™t be too slow. This got me thinking about the various options for tokenizing a string in C++, which led me to this StackOverflow thread.

This is bold. That is not the only thing that exists, though; italic also looks cool. Links look like this.
Sometimes it is a good idea to use Oxford dashes â€“ or properly known as en-dashes â€“ to give extra information that isnâ€™t essential to the sentence.

There are a variety of options mentioned. The objective of this post is to benchmark them. Letâ€™s meet the contendersâ€¦">
	<meta name="keywords" content="C++, Character, String, Boost">
	<meta name="date" content="2016-11-01T00:00:00+01:00">
	
	<!-- OpenGraphs (Twitter Cards) SEO
	<meta property="og:title" content="">
	<meta property="og:image" content="">
	<meta property="og:description" content="">
	-->
</head>

<body>
	<!-- nav -->
	<nav class="nav">
	<div class="wrap">
		<a class="nav__link  nav__link--home" href="/" title="Index"><img src="/favicon.ico" alt="Home"></a>
		<a class="nav__link" href="/blog" title="Blog">Blog</a>
		<a class="nav__link" href="/projects" title="Projects">Projects</a>
		<a class="nav__link" href="/about" title="About" rel="author">About</a>
	</div>
</nav>
	
	<!-- post -->
	<article class="post">
		<!-- post header -->
		<header>
			<div class="wrap">
				<h1>This isnâ€™t stolenâ€¦</h1>
				<h2>
					<a href="/about" class="post-author">Jan Katzer</a>
					<!--<time class="post-date" datetime="2016-11-01T00:00:00+01:00">1st
 Nov '16, Tue</time>-->
					<time class="post-date" datetime="2016-11-01T00:00:00+01:00">1<sup>st</sup> Nov &lsquo;16, Tue</time>
				</h2>
			</div>
		</header>
		
		<!-- post content -->
		<main>
			<div class="wrap">
				<p>After I decided that it would be useful for me to have an OBJ parser in my pile of code. There is a lot of OBJ content kicking around, for example Morgan McGuireâ€™s excellent data repository.</p>

<p>OBJ is a text-based format, which means Iâ€™d need to write a parser, and 3D models are big, which means my parser shouldnâ€™t be too slow. This got me thinking about the various options for tokenizing a string in C++, which led me to this StackOverflow thread.</p>

<p>This is <strong>bold</strong>. That is not the only thing that exists, though; <em>italic</em> also looks cool. Links look like <a href="https://www.google.com">this</a>.
Sometimes it is a good idea to use Oxford dashes â€“ or properly known as en-dashes â€“ to give extra information that isnâ€™t essential to the sentence.</p>

<p>There are a variety of options mentioned. The objective of this post is to benchmark them. Letâ€™s meet the contendersâ€¦
<!--more--></p>

<h3 id="option-1-boost">Option 1: Boost</h3>

<p>Lots of people like boost, and they have a nice, easy to use tokenizer (along with gobs and gobs of other things). Boost was the accepted answer on the StackOverflow article, and it is so popular that some commenters went so far as to declare that it is unreasonable not to assume it. Here is the boost tokenizer benchmark:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">DoBoost</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="o">&amp;</span> <span class="n">cout</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">text</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">char_separator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">sep</span><span class="p">(</span><span class="s">" </span><span class="se">\n\t\r\f</span><span class="s">"</span><span class="p">);</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">tokenizer</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">char_separator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&gt;</span> <span class="n">tokens</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">sep</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">t</span> <span class="o">:</span> <span class="n">tokens</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">t</span> <span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>I used boost 1.59.0 for this, built as per boostâ€™s instructions.</p>

<h3 id="option-2-stream-iterators">Option 2: Stream Iterators</h3>

<p>Somebody else suggested using stream iterators, which I didnâ€™t know were a thing. This lets us build a non-boost tokenizer using only standard library code. Hereâ€™s the original from the StackOverflow post:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">DoIterator</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="o">&amp;</span> <span class="n">cout</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// construct a stream from the string
</span>    <span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="n">strstr</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
 
    <span class="c1">// use stream iterators to copy the stream to the vector as whitespace separated strings
</span>    <span class="n">std</span><span class="o">::</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">it</span><span class="p">(</span><span class="n">strstr</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">end</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">results</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
 
    <span class="c1">// send the vector to stdout.
</span>    <span class="n">std</span><span class="o">::</span><span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">oit</span><span class="p">(</span><span class="n">cout</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">results</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">results</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">oit</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Now, no offense to whoever wrote that, but, as weâ€™ll see, sucking the entire token set into an std::vector of std::strings is, well, wrong ðŸ™‚ and would not have been a fair comparison. I modified it thusly:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">DoIteratorCorrectly</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="o">&amp;</span> <span class="n">cout</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// construct a stream from the string
</span>    <span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="n">strstr</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
 
    <span class="c1">// use stream iterators to read individual strings
</span>    <span class="n">std</span><span class="o">::</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">it</span><span class="p">(</span><span class="n">strstr</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">end</span><span class="p">;</span>
 
    <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span> <span class="n">it</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">cout</span><span class="p">](</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span> <span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">str</span><span class="p">;</span> <span class="p">}</span> <span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<h3 id="option-3-strtok">Option 3: Strtok</h3>

<p>Some grizzled veteran suggested strtok, and was predictably chided for suggesting a non-thread-safe, C-like solution. Somebody else pointed out that strtok needs a non-const pointer to a null-terminated string, which is not something you find lying around very often in C++. Iâ€™m not a big fan of strtok either but letâ€™s give it whirl.</p>

<p>In order to make it non-destructive, weâ€™ll even take a big hit and create our own mutable copy of the input string.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">DoStrtok</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="o">&amp;</span> <span class="n">cout</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">pMutableString</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span> <span class="n">str</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span> <span class="p">);</span>
    <span class="n">strcpy</span><span class="p">(</span> <span class="n">pMutableString</span><span class="p">,</span> <span class="n">str</span><span class="p">.</span><span class="n">c_str</span><span class="p">()</span> <span class="p">);</span>
 
    <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">strtok</span><span class="p">(</span><span class="n">pMutableString</span><span class="p">,</span> <span class="s">" </span><span class="se">\n\t\r\f</span><span class="s">"</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">strtok</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">" </span><span class="se">\n\t\r\f</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">free</span><span class="p">(</span><span class="n">pMutableString</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>To be fair, you couldnâ€™t just copy the whole thing like that if you were streaming tokens from a very large on-disk file, but we could address this with a little more work by wrapping some streaming buffers around it.</p>

<h3 id="option-4-doing-it-ourselves">Option 4: Doing It Ourselves</h3>

<p>Everybody always says you shouldnâ€™t roll your own code for anything interesting, because the standard libraryâ€™s always going to be faster and safer, but letâ€™s ignore them. My home brew has a few disadvantages. It doesnâ€™t handle UTF-8 or locales or any of those niceties, but itâ€™s adequate for what Iâ€™m targeting it for, which is for parsing pure ascii files containing data thatâ€¦ really shouldnâ€™t be ASCII encoded in the first place.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">static</span> <span class="kt">bool</span> <span class="nf">IsDelim</span><span class="p">(</span> <span class="kt">char</span> <span class="n">tst</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">DELIMS</span> <span class="o">=</span> <span class="s">" </span><span class="se">\n\t\r\f</span><span class="s">"</span><span class="p">;</span>
    <span class="k">do</span> <span class="c1">// Delimiter string cannot be empty, so don't check for it.  Real code should assert on it.
</span>    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">tst</span> <span class="o">==</span> <span class="o">*</span><span class="n">DELIMS</span> <span class="p">)</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="o">++</span><span class="n">DELIMS</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">while</span><span class="p">(</span> <span class="o">*</span><span class="n">DELIMS</span> <span class="p">);</span>
 
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">DoJoshsWay</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="o">&amp;</span> <span class="n">cout</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">pMutableString</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span> <span class="n">str</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span> <span class="p">);</span>
    <span class="n">strcpy</span><span class="p">(</span> <span class="n">pMutableString</span><span class="p">,</span> <span class="n">str</span><span class="p">.</span><span class="n">c_str</span><span class="p">()</span> <span class="p">);</span>
 
    <span class="kt">char</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">pMutableString</span><span class="p">;</span>
 
    <span class="c1">// skip leading delimiters
</span>    <span class="k">while</span><span class="p">(</span> <span class="o">*</span><span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">IsDelim</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">)</span>
        <span class="o">++</span><span class="n">p</span><span class="p">;</span>
 
    <span class="k">while</span><span class="p">(</span> <span class="o">*</span><span class="n">p</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// note start of token
</span>        <span class="kt">char</span><span class="o">*</span> <span class="n">pTok</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
 
        <span class="k">do</span><span class="c1">// skip non-delimiters
</span>        <span class="p">{</span>
            <span class="o">++</span><span class="n">p</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">while</span><span class="p">(</span> <span class="o">!</span><span class="n">IsDelim</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">p</span> <span class="p">);</span>
 
        <span class="c1">// clobber trailing delimiter with null
</span>        <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pTok</span><span class="p">;</span> <span class="c1">// send the token
</span> 
        <span class="k">do</span> <span class="c1">// skip null, and any subsequent trailing delimiters
</span>        <span class="p">{</span>
            <span class="o">++</span><span class="n">p</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">while</span><span class="p">(</span> <span class="o">*</span><span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">IsDelim</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">);</span>
    <span class="p">}</span>
 
    <span class="n">free</span><span class="p">(</span><span class="n">pMutableString</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<h3 id="parameters">Parameters</h3>

<p>The contest shall be to tokenize the 20MB obj for â€˜crytek_sponzaâ€™, which may be found here. Iâ€™m testing it by loading the entire file into memory ahead of time and tokenizing out of a string stream, then writing the resulting tokens back to disk. This lets me run multiple test cases back to back without having to worry about disk caching skewing the results. There is I/O on the other end, of course, but since my process never reads that stuff it shouldnâ€™t interfere too much. Whatever noise there is should be evenly distributed amongst the test cases. Results presented are averages over five consecutive runs as measured by boostâ€™s timer. My CPU is a Core i3-4010U. The code for the test is here. I compiled this for x86 with MSVC 2013 express edition. Here is the command line it used:</p>
			</div>
		</main>
	</article>
	
	<!-- footer -->
	<footer class="footer">
	<div class="wrap">
		<a class="footer__link" href="https://github.com/">Powered by GitHub Pages</a>
		<a class="footer__link  footer__link--ornament" href="/"><!-- This isn't semantic, but I cannot be bothered using selectors and pseudo elements - at this point just make it into a link--></a>
		<a class="footer__link" href="/about" rel="author">Designed by Jan Katzer</a>
	</div>
</footer>
</body>
</html>